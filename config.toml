# serial port of the Vitoconnect device, defaults to "/dev/ttyS0", Raspberry 3B+ (and some others) use "/dev/ttyAMA0"
port_vito = "/dev/ttyS0"
# serial port of the Optolink adapter / device, defaults to "/dev/ttyUSB0"
port_opto = "/dev/ttyUSB0"

# log level, one of "none", "error", "warn", "info", "trace" or "verbose" defaults to "warn"
# note: this setting may be changed during runtime and is picked up from this file automatically
log_level = "warn"

# data points to listen to and publish
# (use tools/convert_poll_items.js to convert your existing optolink-splitter poll_list to data_points)
data_points = [
  # [name, addr, [type], [scale]]
    # name: name of the data point, as published
    # addr: address of the data point, either as hexadecimal 0xab01 or as decimal 43873
    # type:
      # "raw" for raw data (0x..., alias for buffer)
      # "int" / "uint" for integer values matching the size of the data (e.g. (u)int16 for 2 bytes)
      #   corner case: 3 byte values are mapped to (u)int16 and 5 byte values to (u)int32
      #      due to a many numerical data points having a trailing status byte that is ignored
      # "byte" for a single byte value (alias for uint8)
      # "vdatetime" for Viessmann specific date and time values
      # "unixtime" for unix timestamps
      # "utf8" for utf8 encoded strings
      # or any data types supported by binary-parser (e.g. uint16)
      # note that byte-bit filters are *not* yet supported
    # scale: a factor to scale the numeric value by, e.g. 0.1 to convert 100 to 10.0
  # if type is set to a number, the data point is treated as a integer matching the size of the data (e.g. (u)int16
  # for 2 bytes), the number represents the scale, scale can the be set to true, to indicate a signed number
  # if no type is given, the data point is treated as a raw

  ["outside_temperature", 0x01C1, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x0101, but not sent by Vitoconnect
  ["averaged_outside_temperature", 0x160D, "int16", 0.1],
  ["averaging_time_outside_temperature", 0x7002, "int16"],

  ["operating_mode", 0xB000, "byte"],

  ["heating_circuit_circulation_pump", 0x048D, "byte"],
  ["secondary_pump", 0x0484, "byte"],

  ["hkl_level", 0x2006, "int16", 0.1],
  ["hkl_slope", 0x2007, "int16", 0.1],
  ["hysteresis", 0x6007, "int16", 0.1], # also as 0x7203, but not sent by Vitoconnect

  ["buffer_temperature", 0x01CB, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x010B, but not sent by Vitoconnect

  ["primary_circuit_flow_temperature", 0xb400, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x0103, but not sent by Vitoconnect
  ["secondary_circuit_flow_temperature", 0xb402, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x0105, but not sent by Vitoconnect
  ["return_temperature", 0x01c6, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x0106, but not sent by Vitoconnect

  ["3way_valve_position", 0x0494, "byte"],

  ["suction_gas_temperature", 0xb409, "int16", 0.1],
  ["suction_gas_pressure", 0xb410, "int16", 0.1],
  ["hot_gas_temperature", 0xb40a, "int16", 0.1],
  ["hot_gas_pressure", 0xb411, "int16", 0.1],
  ["liquid_gas_temperature", 0xb404, "int16", 0.1],
  ["condensation_temperature", 0xb408, "int16", 0.1],
  ["evaporation_temperature", 0xb407, "int16", 0.1],
  ["compressor_power", 0xb423, "uint8"],
  ["ecv_position", 0xb424, "uint8"],

  ["dhw_temperature_storage", 0x01CD, "int16", 0.1], # 3 bytes (sensor temp. w/ status), 2 bytes as 0x010D, but not sent by Vitoconnect
  ["dhw_temperature_setpoint", 0x6000, "int16", 0.1],
  ["dhw_temperature_setpoint2", 0x600C, "int16", 0.1],
  ["dhw_circulation_pump", 0x0490, "byte"],

  #["room_temperature_setpoint_actual", 0x0116, "int16", 0.1],
  #["room_temperature_setpoint_set", 0x011B, "int16", 0.1],
  ["room_temperature_setpoint_normal", 0x2000, "int16", 0.1],
  ["room_temperature_setpoint_reduced", 0x2001, "int16", 0.1],
  ["room_temperature_setpoint_party", 0x2022, "int16", 0.1],

  ["compressor_phase", 0x0E1A, "byte"], # V1AppState, undocumented 0x130B is used by Vitoconnect
  ["compressor_starts", 0x0500, "int32"],
  ["compressor_operating_hours", 0x0580, "uint32", 0.0002777777777777778],
  ["compressor_heating_power", 0x16A0, "uint"],
  ["compressor_power_consumption", 0x16A4, "uint"],

  ["one_time_dhw", 0xB020, "byte"],

  ["energy_balance_factor", 0x163F, "int8"],
  ["energy_balance_heating", 0x1640, "uint32"],
  ["energy_balance_dhw", 0x1650, "uint32"],
  ["energy_balance_heating_electric", 0x1660, "uint32"],
  ["energy_balance_dhw_electric", 0x1670, "uint32"],

  ["annual_performance_factor", 0x1680, "int8", 0.1],
  ["annual_performance_factor_heating", 0x1681, "int8", 0.1],
  ["annual_performance_factor_dhw", 0x1682, "int8", 0.1],

  ["auxiliary_heater_enable", 0x6014, "byte"],
  ["electric_heater_enable", 0x6015, "byte"]
]

# if set (and not empty), the items in this list are polled at the specified intervals
# note: setting a poll_items list, results in optolink-bridge being started in "intercept" mode
# if not set, a PassThrough stream will be used to forward the data from the Optolink bus, if set
# a Transform stream will be used instead, to inject the poll items into the communication
poll_items = [
  # [ival, addr, dlen]
    # ival: the interval in seconds to poll the item
      # warning: the Optolink serial port is using quite a low baud rate of 4800 bauds / bytes, which
      # (with parity bits included, and assuming the average packet size) results in about 20-25 packets
      # that are transmitted via the bus each second. this includes requests and responses, meaning that only
      # about 10-12 requests can be sent per second before the bus becomes saturated. optolink-bridge will
      # only inject one poll request per message sent to the Optolink bus, meaning the maximum polling rate of
      # items is about 5-6 items per second, reducing the Optolink bus throughput in half. thus the intervals
      # in the poll_items list should be set accordingly. say you have 10 items that you each want to poll every
      # second, the polling queue will become over saturated quickly and a warning will be logged to console
    # addr: the address to poll
    # dlen: the length of data to poll, note that your heating device will likely respond with a NAK / ERR, in
      # in case the length of the data is not specified as the address / data type defines it
  [15, 0xb408, 3], # condensation_temperature
  [15, 0xb407, 3]  # evaporation_temperature
]

# the format to publish raw / byte / buffer data, defaults to "hex", one of:
#   "id" or  "identity" (publish binary data to MQTT)
#   "hex" or "hex_upper" (lower/upper case hex string)
#   "0x" or "0x_upper" (lower/upper case hex string with 0x prefix)
#   "base64" (base64 encoded string)
buffer_format = "hex"
# the maximum number of decimals to round to on publish, defaults to 4
max_decimals = 4

# automatically reload data points and poll items from this configuration file if file changes are detected,
# without (!) interrupting the active Vitoconnect / Optolink communication, defaults to true
# note: this setting only affects reloading data points and poll list items, other changes might not be picked up
# also poll_items will only refresh, in case the list was populated, when you started optolink-bridge
# in case you add a item to the (previously empty) poll_items list, you will need to restart optolink-bridge
# (this is because if poll_items is empty, optolink-bridge will start in pass-through mode and is not able to intercept messages)
auto_reload_addr_items = true

[mqtt]

# broker protocol / host / port
url = "mqtt://127.0.0.1:1883"
# broker username
username = "user"
# broker password
password = "password"
# base topic to publish attributes to, defaults to "Vito"
# e.g.: Vito/<dpname>
topic = "Vito"
# suffix to append to the topic, defaults to <dpname>
# allowed wildcards are <addr> (or <dpaddr> as alias) and <dpname>
suffix = "<dpname>"
# retain a "online" topic, e.g. Vito/online, defaults to true / "online", set to a string to use a different topic
# note: if set to false, home assistant will not be able to determine if the devices / entities are available
online = true

# publish unknown data points to MQTT as raw data
publish_unknown_dps = false
# the suffix to use to publish unknown data points, defaults to "raw/<addr>"
unknown_dp_suffix = "raw/<addr>"

[mqtt.options]
# other broker options (see https://github.com/mqttjs/MQTT.js?tab=readme-ov-file#client options)
#...
